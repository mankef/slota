<!DOCTYPE html>
<html lang="ru">
<head>
    <!-- ... –≤–∞—à head –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π ... -->
</head>
<body>
    <!-- ... –≤–µ—Å—å –≤–∞—à HTML ... -->
    
    <script>
        // ==================== 1. CONFIGURATION (–ø–µ—Ä–≤—ã–º) ====================
        const CONFIG = {
            API_URL: '', // –î–ª—è Railway: –ø—É—Å—Ç–æ, —Ç–∞–∫ –∫–∞–∫ API –Ω–∞ —Ç–æ–º –∂–µ –¥–æ–º–µ–Ω–µ
            DEBUG: window.location.hostname === 'localhost'
        };

        // ==================== 2. TELEGRAM WEBAPP (–≤—Ç–æ—Ä—ã–º) ====================
        let tg = window.Telegram?.WebApp || {
            ready: () => console.log('Telegram WebApp mock ready'),
            expand: () => console.log('Telegram WebApp mock expand'),
            enableClosingConfirmation: () => {},
            setHeaderColor: () => {},
            setBackgroundColor: () => {},
            showAlert: (message) => alert(message),
            showPopup: (params) => confirm(params.message),
            showNotification: (params) => console.log('Notification:', params.message),
            HapticFeedback: {
                impactOccurred: () => {},
                notificationOccurred: () => {},
                selectionChanged: () => {}
            },
            initDataUnsafe: {
                user: {
                    id: 'demo_' + Math.floor(Math.random() * 1000000),
                    username: 'demo_user',
                    first_name: 'Demo',
                    last_name: 'User'
                }
            }
        };

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º Telegram WebApp
        tg.ready();
        tg.expand();
        tg.enableClosingConfirmation();
        tg.setHeaderColor('#8A2BE2');
        tg.setBackgroundColor('#4B0082');

        // ==================== 3. STATE & ELEMENTS (–æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ) ====================
        let state, elements, api;
        
        state = {
            balance: 1000,
            betAmount: 100,
            isSpinning: false,
            paymentCheckInterval: null,
            currentInvoiceId: null,
            isInitialized: false,
            lastAction: 0
        };

        elements = {
            balance: document.getElementById('balance'),
            betAmount: document.getElementById('betAmount'),
            slots: [
                document.getElementById('slot1'),
                document.getElementById('slot2'),
                document.getElementById('slot3')
            ],
            resultDisplay: document.getElementById('resultDisplay'),
            spinBtn: document.getElementById('spinBtn'),
            spinText: document.getElementById('spinText'),
            spinLoader: document.getElementById('spinLoader'),
            gamesToday: document.getElementById('gamesToday'),
            todayWin: document.getElementById('todayWin'),
            availableBalance: document.getElementById('availableBalance'),
            withdrawFee: document.getElementById('withdrawFee'),
            depositAmount: document.getElementById('depositAmount'),
            withdrawAmount: document.getElementById('withdrawAmount')
        };

        // ==================== 4. API CLIENT (–ø–æ—Å–ª–µ state –∏ elements) ====================
        const TELEGRAM_USER_ID = tg.initDataUnsafe?.user?.id || 'demo_' + Math.floor(Math.random() * 1000000);
        const USER_HASH = typeof window.Telegram !== 'undefined' ? window.Telegram.WebApp.initData : 'demo_hash';

        class APIClient {
            constructor() {
                this.baseURL = CONFIG.API_URL;
                this.headers = {
                    'Content-Type': 'application/json',
                    'X-User-ID': TELEGRAM_USER_ID,
                    'X-User-Hash': USER_HASH
                };
            }
            
            async request(endpoint, options = {}) {
                const url = this.baseURL ? `${this.baseURL}${endpoint}` : endpoint;
                const config = {
                    method: options.method || 'GET',
                    headers: { ...this.headers, ...options.headers },
                    signal: options.signal
                };
                
                if (options.body) {
                    config.body = JSON.stringify(options.body);
                }
                
                try {
                    const response = await fetch(url, config);
                    
                    if (!response.ok) {
                        const error = await response.json().catch(() => ({}));
                        throw new Error(error.error || `HTTP ${response.status}`);
                    }
                    
                    return await response.json();
                } catch (error) {
                    if (error.name === 'AbortError') {
                        throw new Error('–ó–∞–ø—Ä–æ—Å –æ—Ç–º–µ–Ω–µ–Ω');
                    }
                    
                    if (CONFIG.DEBUG) {
                        console.error(`API Error [${endpoint}]:`, error);
                    }
                    
                    throw error;
                }
            }
            
            async getBalance() {
                return this.request('/api/balance');
            }
            
            async spin(bet) {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 15000);
                
                try {
                    const result = await this.request('/api/spin', {
                        method: 'POST',
                        body: { bet, timestamp: Date.now() },
                        signal: controller.signal
                    });
                    clearTimeout(timeoutId);
                    return result;
                } catch (error) {
                    clearTimeout(timeoutId);
                    throw error;
                }
            }
            
            async createInvoice(amount) {
                return this.request('/api/create-invoice', {
                    method: 'POST',
                    body: { amount, asset: 'USDT' }
                });
            }
            
            async checkInvoice(invoiceId) {
                return this.request(`/api/check-invoice?invoiceId=${invoiceId}`);
            }
            
            async createWithdraw(amount) {
                return this.request('/api/create-withdraw', {
                    method: 'POST',
                    body: { amount, fee: Math.max(1, amount * 0.01) }
                });
            }
            
            async getHistory(filter = 'all', limit = 20, offset = 0) {
                return this.request(`/api/history?filter=${filter}&limit=${limit}&offset=${offset}`);
            }
        }

        api = new APIClient();

        // ==================== 5. GAME LOGIC (–ø–æ—Å–ª–µ API) ====================
        const symbols = [
            { emoji: 'üçí', weight: 30, multiplier: 2 },
            { emoji: 'üçã', weight: 25, multiplier: 3 },
            { emoji: 'üçä', weight: 20, multiplier: 4 },
            { emoji: 'üçá', weight: 15, multiplier: 5 },
            { emoji: 'üîî', weight: 6, multiplier: 10 },
            { emoji: '‚≠ê', weight: 3, multiplier: 20 },
            { emoji: '7Ô∏è‚É£', weight: 1, multiplier: 100 }
        ];

        function getWeightedSymbol() {
            const totalWeight = symbols.reduce((sum, s) => sum + s.weight, 0);
            let random = Math.random() * totalWeight;
            for (const symbol of symbols) {
                random -= symbol.weight;
                if (random <= 0) return symbol;
            }
            return symbols[0];
        }

        // ==================== 6. UI FUNCTIONS (–ø–æ—Å–ª–µ –≤—Å–µ—Ö –æ–±—ä—è–≤–ª–µ–Ω–∏–π) ====================
        function updateBalance(newBalance) {
            if (typeof newBalance === 'number') {
                state.balance = newBalance;
            }
            elements.balance.textContent = state.balance.toFixed(2);
            elements.availableBalance.textContent = state.balance.toFixed(2);
            
            if (state.betAmount > state.balance) {
                state.betAmount = state.balance;
                elements.betAmount.textContent = state.betAmount;
            }
        }

        function changeBet(delta) {
            const now = Date.now();
            if (now - state.lastAction < 300) return;
            state.lastAction = now;

            const newBet = state.betAmount + delta;
            if (newBet >= 10 && newBet <= 5000 && newBet <= state.balance) {
                state.betAmount = newBet;
                elements.betAmount.textContent = state.betAmount;
                tg.HapticFeedback.selectionChanged();
            }
        }

        async function spin() {
            const now = Date.now();
            if (now - state.lastAction < 500) return;
            state.lastAction = now;

            if (state.isSpinning || state.betAmount > state.balance) {
                showNotification(state.betAmount > state.balance ? '–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤!' : '–ü–æ–¥–æ–∂–¥–∏—Ç–µ...', 'error');
                return;
            }

            state.isSpinning = true;
            elements.spinBtn.disabled = true;
            elements.spinText.style.display = 'none';
            elements.spinLoader.style.display = 'block';
            elements.resultDisplay.textContent = '';
            elements.resultDisplay.className = 'result-display';

            elements.slots.forEach(slot => {
                slot.classList.add('spinning');
                slot.textContent = '?';
            });

            try {
                const data = await api.spin(state.betAmount);
                
                await new Promise(resolve => setTimeout(resolve, 800));
                
                for (let i = 0; i < elements.slots.length; i++) {
                    await new Promise(resolve => setTimeout(resolve, 200));
                    elements.slots[i].classList.remove('spinning');
                    elements.slots[i].textContent = data.results[i];
                }
                
                updateBalance(data.newBalance);
                updateStats();

                if (data.win > 0) {
                    elements.resultDisplay.textContent = `üéâ –í–´–ò–ì–†–´–® $${data.win.toFixed(2)}!`;
                    elements.resultDisplay.className = 'result-display win';
                    tg.HapticFeedback.notificationOccurred('success');
                } else {
                    elements.resultDisplay.textContent = '–ü–æ–≤–µ–∑—ë—Ç –≤ —Å–ª–µ–¥—É—é—â–∏–π —Ä–∞–∑!';
                    elements.resultDisplay.className = 'result-display lose';
                    tg.HapticFeedback.notificationOccurred('warning');
                }
                
            } catch (error) {
                console.error('Spin error:', error);
                elements.slots.forEach(slot => {
                    slot.classList.remove('spinning');
                    slot.textContent = getWeightedSymbol().emoji;
                });
                elements.resultDisplay.textContent = '–û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.';
                elements.resultDisplay.className = 'result-display lose';
                tg.HapticFeedback.notificationOccurred('error');
            } finally {
                state.isSpinning = false;
                elements.spinBtn.disabled = false;
                elements.spinText.style.display = 'block';
                elements.spinLoader.style.display = 'none';
            }
        }

        function showDepositModal() {
            document.getElementById('depositModal').style.display = 'flex';
            document.getElementById('paymentInfo').style.display = 'none';
            document.getElementById('createDepositBtn').style.display = 'block';
            
            if (state.paymentCheckInterval) {
                clearInterval(state.paymentCheckInterval);
                state.paymentCheckInterval = null;
            }
            
            tg.HapticFeedback.impactOccurred('light');
        }

        async function createDeposit() {
            const amount = parseFloat(elements.depositAmount.value);
            if (!amount || amount < 10) {
                showNotification('–ú–∏–Ω–∏–º—É–º 10 USDT', 'error');
                return;
            }
            
            document.getElementById('paymentInfo').style.display = 'block';
            document.getElementById('createDepositBtn').style.display = 'none';
            document.getElementById('paymentAmount').textContent = amount;
            document.getElementById('paymentStatus').className = 'status-display status-pending';
            document.getElementById('paymentStatus').innerHTML = '‚è≥ –°–æ–∑–¥–∞–Ω–∏–µ –ø–ª–∞—Ç–µ–∂–∞...';
            document.getElementById('paymentLoader').style.display = 'block';
            
            try {
                const data = await api.createInvoice(amount);
                
                document.getElementById('cryptoAddress').textContent = data.invoice.address;
                document.getElementById('cryptoNetwork').textContent = data.invoice.network || 'TRC20';
                document.getElementById('paymentStatus').innerHTML = '‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ –æ–ø–ª–∞—Ç—ã...';
                
                updateQRCode(data.invoice.address, amount);
                
                state.currentInvoiceId = data.invoiceId;
                startPaymentCheck(data.invoiceId);
                
            } catch (error) {
                console.error('Create deposit error:', error);
                document.getElementById('paymentStatus').className = 'status-display status-error';
                document.getElementById('paymentStatus').innerHTML = '‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è';
                document.getElementById('createDepositBtn').style.display = 'block';
                document.getElementById('paymentLoader').style.display = 'none';
                showNotification('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–ª–∞—Ç–µ–∂–∞', 'error');
                tg.HapticFeedback.notificationOccurred('error');
            }
        }

        function updateQRCode(address, amount) {
            const shortAddress = `${address.substring(0, 8)}...${address.substring(address.length - 8)}`;
            document.getElementById('qrAddress').textContent = shortAddress;
        }

        function startPaymentCheck(invoiceId) {
            if (state.paymentCheckInterval) {
                clearInterval(state.paymentCheckInterval);
            }
            
            let checkCount = 0;
            const maxChecks = 180;
            
            state.paymentCheckInterval = setInterval(async () => {
                try {
                    checkCount++;
                    const data = await api.checkInvoice(invoiceId);
                    
                    if (data.status === 'paid') {
                        clearInterval(state.paymentCheckInterval);
                        state.paymentCheckInterval = null;
                        
                        document.getElementById('paymentStatus').className = 'status-display status-success';
                        document.getElementById('paymentStatus').innerHTML = '‚úÖ –û–ø–ª–∞—Ç–∞ –ø–æ–ª—É—á–µ–Ω–∞!';
                        document.getElementById('paymentLoader').style.display = 'none';
                        
                        updateBalance(data.newBalance || (state.balance + data.amount));
                        updateStats();
                        
                        showNotification(`–ë–∞–ª–∞–Ω—Å –ø–æ–ø–æ–ª–Ω–µ–Ω –Ω–∞ $${data.amount.toFixed(2)}!`, 'success');
                        tg.HapticFeedback.notificationOccurred('success');
                        
                        setTimeout(() => {
                            closeModal('depositModal');
                        }, 2500);
                    } else if (data.status === 'expired') {
                        clearInterval(state.paymentCheckInterval);
                        state.paymentCheckInterval = null;
                        document.getElementById('paymentStatus').className = 'status-display status-error';
                        document.getElementById('paymentStatus').innerHTML = '‚ùå –í—Ä–µ–º—è –∏—Å—Ç–µ–∫–ª–æ';
                        document.getElementById('createDepositBtn').style.display = 'block';
                        document.getElementById('paymentLoader').style.display = 'none';
                    } else if (checkCount >= maxChecks) {
                        clearInterval(state.paymentCheckInterval);
                        state.paymentCheckInterval = null;
                        document.getElementById('paymentStatus').innerHTML = '‚åõ –í—Ä–µ–º—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∏—Å—Ç–µ–∫–ª–æ';
                        document.getElementById('paymentLoader').style.display = 'none';
                    }
                } catch (error) {
                    console.error('Payment check error:', error);
                }
            }, 10000);
        }

        function showWithdrawModal() {
            document.getElementById('withdrawModal').style.display = 'flex';
            document.getElementById('checkDisplay').style.display = 'none';
            document.getElementById('createWithdrawBtn').style.display = 'block';
            
            const amount = parseFloat(elements.withdrawAmount.value) || 0;
            const fee = Math.max(1, amount * 0.01);
            document.getElementById('withdrawFee').textContent = fee.toFixed(2);
            
            tg.HapticFeedback.impactOccurred('light');
        }

        async function createWithdraw() {
            const amount = parseFloat(elements.withdrawAmount.value);
            const fee = parseFloat(document.getElementById('withdrawFee').textContent);
            const total = amount + fee;
            
            if (!amount || amount < 20) {
                showNotification('–ú–∏–Ω–∏–º—É–º 20 USDT', 'error');
                return;
            }
            
            if (total > state.balance) {
                showNotification('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤', 'error');
                tg.HapticFeedback.notificationOccurred('error');
                return;
            }
            
            try {
                const data = await api.createWithdraw(amount);
                
                document.getElementById('checkDisplay').style.display = 'block';
                document.getElementById('createWithdrawBtn').style.display = 'none';
                document.getElementById('checkCode').textContent = data.checkCode;
                document.getElementById('checkAmount').textContent = amount.toFixed(2);
                
                updateBalance(state.balance - total);
                updateStats();
                
                copyToClipboard(data.checkCode);
                showNotification('–ß–µ–∫ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω!', 'success');
                tg.HapticFeedback.notificationOccurred('success');
                
            } catch (error) {
                console.error('Withdraw error:', error);
                showNotification('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —á–µ–∫–∞', 'error');
                tg.HapticFeedback.notificationOccurred('error');
            }
        }

        function showHistoryModal() {
            document.getElementById('historyModal').style.display = 'flex';
            loadHistory();
            tg.HapticFeedback.impactOccurred('light');
        }

        async function loadHistory(filter = 'all') {
            const historyTable = document.getElementById('historyTable');
            historyTable.innerHTML = '<div style="text-align: center; padding: 40px 20px;"><div class="loader"></div><div style="margin-top: 16px; font-size: 14px;">–ó–∞–≥—Ä—É–∑–∫–∞...</div></div>';
            
            try {
                const data = await api.getHistory(filter, 20, 0);
                
                if (data.history && data.history.length > 0) {
                    displayHistory(data.history);
                    document.getElementById('loadMoreBtn').style.display = data.hasMore ? 'block' : 'none';
                } else {
                    historyTable.innerHTML = '<div style="text-align: center; padding: 40px; color: #D8BFD8;">–ù–µ—Ç –æ–ø–µ—Ä–∞—Ü–∏–π</div>';
                    document.getElementById('loadMoreBtn').style.display = 'none';
                }
            } catch (error) {
                console.error('Load history error:', error);
                historyTable.innerHTML = '<div style="text-align: center; padding: 40px; color: #FF4444;">–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏</div>';
            }
        }

        function displayHistory(history) {
            const historyTable = document.getElementById('historyTable');
            const iconMap = { 'deposit': 'üíé', 'withdraw': 'üí∞', 'win': 'üéâ', 'bet': 'üé∞' };
            const colorMap = { 'deposit': '#00FF00', 'withdraw': '#FF4444', 'win': '#00FF00', 'bet': '#FF4444' };
            const nameMap = { 'deposit': '–ü–æ–ø–æ–ª–Ω–µ–Ω–∏–µ', 'withdraw': '–í—ã–≤–æ–¥', 'win': '–í—ã–∏–≥—Ä—ã—à', 'bet': '–°—Ç–∞–≤–∫–∞' };
            
            historyTable.innerHTML = history.map(item => {
                const date = new Date(item.timestamp).toLocaleString('ru-RU', {
                    day: '2-digit', month: '2-digit', hour: '2-digit', minute: '2-digit'
                });
                const sign = item.type === 'deposit' || item.type === 'win' ? '+' : '-';
                const color = colorMap[item.type];
                const icon = iconMap[item.type];
                const name = nameMap[item.type];
                
                return `
                    <div class="history-item history-type ${item.type}">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <div style="font-size: 18px;">${icon}</div>
                            <div>
                                <div style="font-weight: 600; font-size: 14px;">${name}</div>
                                <div style="font-size: 11px; color: #D8BFD8;">${date}</div>
                            </div>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-weight: 800; color: ${color}; font-size: 14px;">
                                ${sign}$${item.amount.toFixed(2)}
                            </div>
                            ${item.status ? `<div style="font-size: 10px; color: #D8BFD8;">${item.status}</div>` : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function filterHistory(filter) {
            ['all', 'deposit', 'withdraw'].forEach(f => {
                const btn = document.getElementById(`filter${f.charAt(0).toUpperCase() + f.slice(1)}`);
                btn.style.background = f === filter ? 'var(--gradient-accent)' : 'rgba(0,0,0,0.3)';
            });
            loadHistory(filter);
            tg.HapticFeedback.selectionChanged();
        }

        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
            if (state.paymentCheckInterval) {
                clearInterval(state.paymentCheckInterval);
                state.paymentCheckInterval = null;
            }
            tg.HapticFeedback.impactOccurred('light');
        }

        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                showNotification('–°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ!', 'success');
                tg.HapticFeedback.notificationOccurred('success');
            }).catch(() => {
                const textArea = document.createElement('textarea');
                textArea.value = text;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                showNotification('–°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ!', 'success');
            });
        }

        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed; top: 20px; right: 20px; padding: 12px 16px; border-radius: 8px;
                color: white; font-weight: 600; z-index: 10000; animation: slideInRight 0.3s ease, fadeOut 0.3s ease 2.7s forwards;
                box-shadow: 0 5px 15px rgba(0,0,0,0.3); max-width: 280px; font-size: 14px;
            `;
            notification.style.background = type === 'success' ? 'linear-gradient(135deg, #00b09b, #96c93d)' : 
                                           type === 'error' ? 'linear-gradient(135deg, #ff416c, #ff4b2b)' : 
                                           'linear-gradient(135deg, #8A2BE2, #4B0082)';
            notification.textContent = message;
            document.body.appendChild(notification);
            setTimeout(() => notification.remove(), 3000);
        }

        function updateStats() {
            const games = parseInt(elements.gamesToday.textContent);
            elements.gamesToday.textContent = games + 1;
            const currentWin = parseFloat(elements.todayWin.textContent.replace('$', ''));
            elements.todayWin.textContent = `$${(currentWin + Math.random() * 50).toFixed(2)}`;
        }

        // ==================== 7. INITIALIZATION ====================
        async function initializeApp() {
            if (state.isInitialized) return;
            
            try {
                const data = await api.getBalance();
                updateBalance(data.balance || 1000);
                
                if (data.gamesPlayed !== undefined) {
                    elements.gamesToday.textContent = data.gamesPlayed;
                }
                if (data.totalWins !== undefined) {
                    elements.todayWin.textContent = `$${(data.totalWins || 0).toFixed(2)}`;
                }
                
                state.isInitialized = true;
                
                if (CONFIG.DEBUG) {
                    console.log('‚úÖ App initialized:', {
                        userId: TELEGRAM_USER_ID,
                        balance: state.balance
                    });
                }
                
            } catch (error) {
                console.error('Initialization error:', error);
                showNotification('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö', 'error');
            }
        }

        // ==================== 8. EVENT LISTENERS ====================
        document.addEventListener('DOMContentLoaded', () => {
            initializeApp();
            
            elements.withdrawAmount.addEventListener('input', function() {
                const amount = parseFloat(this.value) || 0;
                const fee = Math.max(1, amount * 0.01);
                document.getElementById('withdrawFee').textContent = fee.toFixed(2);
                tg.HapticFeedback.selectionChanged();
            });
            
            document.querySelectorAll('.modal').forEach(modal => {
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        closeModal(modal.id);
                    }
                });
            });
            
            let lastTouchEnd = 0;
            document.addEventListener('touchend', function (event) {
                const now = (new Date()).getTime();
                if (now - lastTouchEnd <= 300) {
                    event.preventDefault();
                }
                lastTouchEnd = now;
            }, false);
        });

        // ==================== 9. ERROR HANDLERS ====================
        window.addEventListener('error', function(event) {
            console.error('Global error:', event.error);
            if (CONFIG.DEBUG) {
                showNotification('–û—à–∏–±–∫–∞: ' + event.error.message, 'error');
            }
        });

        window.addEventListener('unhandledrejection', function(event) {
            console.error('Unhandled rejection:', event.reason);
            showNotification('Promise error', 'error');
        });

        // ==================== 10. DEBUG INFO ====================
        if (CONFIG.DEBUG) {
            console.log('üîß DEBUG MODE ON');
            console.log('Telegram User:', tg.initDataUnsafe?.user);
            console.log('API Client:', api);
            console.log('State:', state);
        }
    </script>
</body>
</html>
